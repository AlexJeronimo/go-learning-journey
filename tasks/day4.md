# Тиждень 1, День 4. Робота з Файлами, Серіалізація та Основи Вебу
**Мета:** Навчитися працювати з файловою системою, обробляти дані в поширених форматах (JSON/XML) та створювати базові HTTP-сервери. Це фундаментальні навички для будь-якого розробника на Go, оскільки більшість реальних додатків взаємодіють з файлами, обмінюються даними та працюють через мережу.

### Короткий огляд:

1. **Пакет `os` та `io`:** Основні пакети для взаємодії з файловою системою.
    - `os.ReadFile()`, `os.WriteFile()`: Прості функції для читання/запису всього файлу.
    - `os.Open()`, `os.Create()`: Для більш контрольованої роботи з файлами (потоками).
    - `bufio.NewReader()`, `bufio.NewWriter()`: Для ефективного буферизованого читання/запису.
    - `io.Copy()`: Ефективне копіювання з одного `Reader` в інший `Writer`.
2. **Пакет `encoding/json` та `encoding/xml`:** Для перетворення структур Go у відповідні формати та назад.
    - `json.Marshal()`: Структура Go -> JSON-байти.
    - `json.Unmarshal()`: JSON-байти -> Структура Go.
    - `json.NewEncoder()`, `json.NewDecoder()`: Для потокової роботи з JSON (наприклад, з `http.ResponseWriter` або `os.File`).
    - Теги полів структури (`json:"fieldName"`) для налаштування імен та поведінки (наприклад, `omitempty`).
3. **Пакет `net/http`:** Основа для побудови веб-серверів та клієнтів у Go.
    - `http.HandleFunc(pattern, handler)`: Реєструє функцію-обробник для певного URL-шляху.
    - `http.ResponseWriter`: Інтерфейс для запису HTTP-відповіді.
    - `*http.Request`: Об'єкт, що містить інформацію про HTTP-запит (URL, методи, заголовки, тіло).
    - `http.ListenAndServe(addr, handler)`: Запускає HTTP-сервер.

---

### Практичні Завдання:

Створіть новий проект або окремий файл `day4_tasks.go` у вашій робочій папці.

---

#### Завдання 1: Робота з Файлами (Читання/Запис/Копіювання/Лістинг)

Ці завдання охоплюють базові операції з файлами. Звертайте увагу на обробку помилок!

1. **Читання та Запис Текстових Файлів:**
    
    - **Мета:** Створити прості функції для збереження та завантаження текстових даних.
    - **Функції:**
        - `func writeToFile(filename string, content string) error`:
            - Приймає ім'я файлу та рядок вмісту.
            - Записує `content` у файл `filename`.
            - Повинен повертати `nil` у разі успіху або помилку (`error`) у разі невдачі (наприклад, якщо не вдалося створити/відкрити файл).
            - Використовуйте `os.WriteFile` для простоти.
        - `func readFromFile(filename string) (string, error)`:
            - Приймає ім'я файлу.
            - Читає весь вміст файлу.
            - Повертає вміст файлу як `string` та `nil` у разі успіху, або порожній рядок та помилку (`error`) у разі невдачі.
            - Використовуйте `os.ReadFile`.
    - **У `main`:**
        - Визначте ім'я тестового файлу (наприклад, `"my_test_file.txt"`).
        - Запишіть у нього рядок: `"Привіт, Go!"` та `"Це мій перший файл."` (кожне в новому рядку).
        - Прочитайте вміст файлу та виведіть його у консоль.
        - Обов'язково обробляйте помилки від функцій `writeToFile` та `readFromFile`.
2. **Копіювання Файлів:**
    
    - **Мета:** Реалізувати функцію для копіювання даних з одного файлу в інший.
    - **Функція:** `func copyFile(src, dst string) error`:
        - Приймає шлях до вихідного файлу (`src`) та шлях до цільового файлу (`dst`).
        - Відкриває `src` для читання та `dst` для запису (створює його, якщо не існує, або перезаписує).
        - Копіює весь вміст з `src` у `dst`.
        - **Важливо:** Не забудьте закрити файли за допомогою `defer file.Close()`.
        - Використовуйте `os.Open`, `os.Create` та `io.Copy`.
    - **У `main`:**
        - Використайте файл, створений у Завданні 1.1, як `src`.
        - Створіть нове ім'я для `dst` (наприклад, `"my_copied_file.txt"`).
        - Викличте `copyFile`.
        - Після копіювання прочитайте вміст `dst` і виведіть його, щоб переконатися, що копія успішна.
3. **Список Файлів у Директорії:**
    
    - **Мета:** Навчитися переглядати вміст директорій.
    - **Функція:** `func listFiles(dirPath string) ([]string, error)`:
        - Приймає шлях до директорії (`dirPath`).
        - Повертає зріз (`[]string`) імен файлів та піддиректорій, що знаходяться безпосередньо у `dirPath`.
        - Використовуйте `os.ReadDir(dirPath)`. Ітеруйте по отриманих `fs.DirEntry` та збирайте їхні імена.
    - **У `main`:**
        - Викличте `listFiles` для поточної директорії (`"."`).
        - Виведіть список знайдених файлів/папок.
        - Обробляйте можливі помилки (наприклад, якщо директорія не існує).

---

#### Завдання 2: Серіалізація/Десеріалізація (JSON)

JSON є найпопулярнішим форматом обміну даними. Go має чудову вбудовану підтримку для роботи з ним.

1. **JSON - Структура до JSON-рядка:**
    
    - **Мета:** Перетворити об'єкт Go у JSON-рядок.
    - **Структура:**

        
        ```go
        type User struct {
            Name  string `json:"name"`
            Email string `json:"email,omitempty"` // omitempty означає, що поле буде пропущено, якщо воно порожнє
            Age   int    `json:"age"`
            IsActive bool `json:"is_active"`
        }
        ```
        
    - **У `main`:**
        - Створіть об'єкт `User` (наприклад, `u := User{Name: "Alice", Email: "alice@example.com", Age: 30, IsActive: true}`).
        - Використайте `json.Marshal(u)` для серіалізації об'єкта `u` у JSON-байти.
        - Перетворіть байти у рядок (`string(jsonBytes)`) і виведіть його.
        - Обробляйте помилки.
2. **JSON - JSON-рядок до Структури:**
    
    - **Мета:** Перетворити JSON-рядок назад в об'єкт Go.
    - **У `main`:**
        - Визначте JSON-рядок, який ви хочете десеріалізувати (можна взяти той, що отримали у попередньому завданні, або просто скопіювати сюди, наприклад: `jsonString :=`{"name":"Bob","email":"bob@example.com","age":25,"is_active":false}``).
        - Створіть порожній об'єкт `User` для десеріалізації: `var newUser User`.
        - Використайте `json.Unmarshal([]byte(jsonString), &newUser)` для десеріалізації.
        - Виведіть поля `newUser` (Name, Email, Age, IsActive), щоб переконатися, що десеріалізація успішна.
        - Обробляйте помилки.
3. **JSON - Робота з файлами JSON:**
    
    - **Мета:** Зберігати та завантажувати колекції об'єктів у JSON-файлах.
    - **У `main`:**
        - Створіть зріз об'єктів `User` (наприклад, 3-4 об'єкти).
        - Визначте ім'я файлу (наприклад, `"users.json"`).
        - **Запис:**
            - Серіалізуйте зріз `[]User` у JSON-байти.
            - Запишіть ці байти у файл `users.json` (використовуйте `os.WriteFile`).
        - **Читання:**
            - Прочитайте вміст `users.json` у байти.
            - Десеріалізуйте ці байти у новий зріз `[]User` (`var loadedUsers []User`).
            - Ітеруйте по `loadedUsers` і виведіть інформацію про кожного користувача.
        - Обробляйте всі можливі помилки.

---

#### Завдання 3: Основи HTTP-серверів

Це ваші перші кроки у створенні веб-сервісів на Go.

1. **Простий "Hello World" Веб-сервер:**
    
    - **Мета:** Запустити базовий HTTP-сервер, який відповідає на запити.
    - **У `main`:**
        - Використайте `http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { ... })`. Функція-обробник повинна просто писати `fmt.Fprintf(w, "Hello, Go Web!")` у `http.ResponseWriter`.
        - Запустіть сервер: `http.ListenAndServe(":8080", nil)`. Другий аргумент `nil` означає використання стандартного маршрутизатора `http.DefaultServeMux`.
        - **Перевірка:** Запустіть програму, відкрийте браузер та перейдіть за адресою `http://localhost:8080/`. Ви маєте побачити "Hello, Go Web!".
2. **Обробка Запитів з Параметрами:**
    
    - **Мета:** Зчитувати параметри з URL-запиту.
    - **У `main` (модифікуйте попередній `http.HandleFunc` або створіть новий для `/greet`):**
        - Для шляху `/greet` створіть обробник:

            ```go
            http.HandleFunc("/greet", func(w http.ResponseWriter, r *http.Request) {
                name := r.URL.Query().Get("name") // Отримуємо значення параметра "name"
                if name == "" {
                    name = "гість" // Значення за замовчуванням, якщо параметр відсутній
                }
                fmt.Fprintf(w, "Привіт, %s!", name)
            })
            ```
            
        - **Перевірка:** Відкрийте `http://localhost:8080/greet` та `http://localhost:8080/greet?name=Олена` у браузері.
3. **JSON API Ендпоінт:**
    
    - **Мета:** Створити простий API-ендпоінт, який повертає дані у форматі JSON.
    - **У `main` (додайте новий `http.HandleFunc` для `/api/user`):**
        - Створіть анонімну структуру або використайте структуру `User` з попереднього завдання.
        - Всередині обробника:
            - Встановіть заголовок `Content-Type`: `w.Header().Set("Content-Type", "application/json")`. Це важливо, щоб клієнт знав, що він отримує JSON.
            - Створіть об'єкт, який будете кодувати в JSON (наприклад, `data := struct{Name string; Email string}{Name: "Jane Doe", Email: "jane@example.com"}`).
            - Використайте `json.NewEncoder(w).Encode(data)` для кодування об'єкта безпосередньо у `http.ResponseWriter`. Це ефективніше, ніж спочатку маршалити в байти, а потім писати байти.
        - **Перевірка:** Відкрийте `http://localhost:8080/api/user` у браузері. Ви маєте побачити JSON-дані.