# Тиждень 1, День 3: Конкурентність (Основи Goroutines та Channels)

Сьогодні ми зануримося у одну з найпотужніших та найцікавіших особливостей Go – **конкурентність**. Go був розроблений з нуля з урахуванням конкурентності, що робить його надзвичайно ефективним для паралельних обчислень.

### Теоретична частина:

1. **Конкурентність vs. Паралелізм:**
    
    - **Конкурентність (Concurrency):** Організація багатьох речей, які відбуваються _одночасно_ (або здаються такими). Це означає, що програма може обробляти кілька задач, чергуючи виконання між ними. Одна людина жонглює трьома м'ячами (конкурентно, але не паралельно).
    - **Паралелізм (Parallelism):** Фактичне виконання багатьох речей _одночасно_ (наприклад, на кількох ядрах процесора). Три людини жонглюють по одному м'ячу кожна (паралельно).
    - **Go сприяє конкурентності**, що може призвести до паралелізму, якщо у вас достатньо ядер процесора.
2. **Goroutines:**
    
    - Goroutines — це легкі, незалежні потоки виконання в Go. Вони схожі на потоки (threads), але набагато менш ресурсоємні (можна запустити мільйони goroutines на одному комп'ютері).
    - Вони запускаються за допомогою ключового слова `go` перед викликом функції: `go someFunction()`.
    - Goroutines працюють у фоновому режимі, і `main` функція не чекає їх завершення автоматично. Якщо `main` завершується, всі активні goroutines також зупиняються.
    - Основний принцип Go-конкурентності: **"Do not communicate by sharing memory; instead, share memory by communicating."** (Не обмінюйтеся даними, використовуючи спільну пам'ять; натомість, обмінюйтеся пам'яттю шляхом комунікації). Це веде нас до каналів.
3. **Channels (Канали):**
    
    - Канали — це "труби", через які goroutines можуть безпечно обмінюватися даними. Це запобігає проблемам з гонками даних (data races), які часто виникають при використанні спільної пам'яті.
    - **Створення каналу:** `ch := make(chan Type)`.
    - **Надсилання даних у канал:** `ch <- value`. Це блокуюча операція, доки хтось не прийме значення.
    - **Приймання даних з каналу:** `value := <-ch`. Це також блокуюча операція, доки хтось не надішле значення.
    - **Буферизовані та небуферизовані канали:**
        - **Небуферизовані (unbuffered):** `ch := make(chan Type)`. Надсилання/приймання блокується, доки обидві сторони (sender і receiver) не будуть готові. Це синхронний обмін.
        - **Буферизовані (buffered):** `ch := make(chan Type, capacity)`. Канал може зберігати до `capacity` значень без блокування відправника. Відправник блокується, тільки якщо буфер повний. Отримувач блокується, тільки якщо буфер порожній.
    - **Закриття каналу:** `close(ch)`. Після закриття каналу, дані можна продовжувати читати з нього, доки буфер не спорожніє. Надсилання даних у закритий канал призведе до `panic`. Отримування з закритого каналу поверне нульове значення типу каналу та `false` для `ok` значення (`value, ok := <-ch`).
    - **`range` з каналами:** Можна ітерувати по каналу за допомогою `for range`, щоб отримувати значення, доки канал не буде закритий.
4. **`sync.WaitGroup`:**
    
    - Оскільки `main` функція не чекає завершення goroutines, нам потрібен механізм для координації. `sync.WaitGroup` дозволяє `main` функції (або будь-якій іншій goroutine) чекати, доки набір goroutines не завершить свою роботу.
    - **`wg.Add(n)`:** Збільшує лічильник на `n`.
    - **`wg.Done()`:** Зменшує лічильник на 1. Має бути викликаний у кожній goroutine після її завершення (часто використовується з `defer wg.Done()`).
    - **`wg.Wait()`:** Блокує виконання, доки лічильник не стане нулем.

### Ресурси для вивчення:

- **Обов'язково:**
    - **A Tour of Go: Concurrency:** [https://go.dev/tour/concurrency/1](https://go.dev/tour/concurrency/1) (Прочитайте всі розділи про Goroutines та Channels, включаючи Select та Default Selection - але основна увага на goroutines та channels).
    - **Go by Example: Goroutines:** [https://gobyexample.com/goroutines](https://gobyexample.com/goroutines)
    - **Go by Example: Channels:** [https://gobyexample.com/channels](https://gobyexample.com/channels)
    - **Go by Example: Channel Buffering:** [https://gobyexample.com/channel-buffering](https://gobyexample.com/channel-buffering)
    - **Go by Example: Channel Synchronization:** [https://gobyexample.com/channel-synchronization](https://gobyexample.com/channel-synchronization)
    - **Go by Example: WaitGroups:** [https://gobyexample.com/waitgroups](https://gobyexample.com/waitgroups)
    - Ваша книга **"Мова програмування Go"** - розділи про конкурентність.
- **Дуже корисно (для розуміння філософії):**
    - **Go Blog: Concurrency is not Parallelism:** [https://go.dev/blog/waza-talk](https://go.dev/blog/waza-talk) (Це класика, але може бути трохи складнішою на початку. Прочитайте для загального розуміння концепцій).

### Практична частина:

Створіть новий проект (або в межах існуючого `go_learning_project` створіть нову піддиректорію, наприклад, `day3_concurrency`).

**Завдання 1: Паралельний лічильник слів (початковий варіант)**

- Напишіть функцію `countWords(text string, wordCountChan chan map[string]int)`, яка приймає текст і канал для надсилання результатів.
- Функція повинна:
    - Розбити текст на слова.
    - Підрахувати кількість входжень кожного слова (використовуйте `map[string]int`).
    - Надіслати отриману мапу в канал `wordCountChan`.
- У функції `main`:
    - Майте зріз з кількома довгими рядками тексту (можете використовувати кілька параграфів з будь-якого джерела).
    - Створіть небуферизований канал `wordCountChan` типу `chan map[string]int`.
    - Для кожного рядка тексту в зрізі **запустіть окрему goroutine**, яка викликає `countWords`.
    - Використовуйте `sync.WaitGroup` для того, щоб `main` функція чекала завершення всіх `countWords` goroutines.
    - Після того, як всі goroutines завершились (тобто після `wg.Wait()`), **закрийте канал `wordCountChan`**.
    - Потім у `main` (або в окремій goroutine, яка слухає результати), **читайте з `wordCountChan` за допомогою `for range`**, доки канал не буде закритий.
    - Виведіть результат кожної goroutine.

**Завдання 2: "Пул воркерів" для обробки чисел**

- Створіть функцію `worker(id int, jobs <-chan int, results chan<- int)`.
    - `id`: Ідентифікатор воркера (для логування).
    - `jobs`: Канал **тільки для читання** (використовуйте `<-chan int`) для отримання завдань.
    - `results`: Канал **тільки для запису** (використовуйте `chan<- int`) для надсилання результатів.
- Кожен воркер повинен:
    - У нескінченному циклі `for range jobs` читати числа з каналу `jobs`.
    - "Обробляти" число, наприклад, множити його на 2 і симулювати затримку `time.Sleep(100 * time.Millisecond)`.
    - Надсилати оброблений результат у канал `results`.
    - Виводити в консоль, який воркер (за `id`) обробив яке число.
- У функції `main`:
    - Створіть два канали: `jobs` (буде надсилати завдання) та `results` (буде отримувати результати).
    - **Запустіть 3 goroutines `worker`**, передаючи їм ці канали.
    - Створіть `sync.WaitGroup`.
    - Запустіть окрему goroutine, яка буде **генерувати 10 випадкових завдань** (цілих чисел) і надсилати їх у канал `jobs`. Після надсилання всіх завдань **закрийте канал `jobs`**.
    - Запустіть ще одну окрему goroutine, яка буде **читати 10 результатів** з каналу `results`. Вона повинна чекати на всі результати (використовуйте `WaitGroup` або інший механізм).
    - У `main` функції використовуйте `wg.Wait()` для очікування завершення всіх воркерів та збирача результатів. **НЕ закривайте канал `results` у цьому завданні, щоб уникнути блокування або паніки, якщо збирач ще не всі отримав.** Ми до цього повернемося пізніше.

---

**Підказки:**

- Не забувайте про `defer wg.Done()` у ваших goroutines, щоб лічильник `WaitGroup` зменшувався.
- Для симуляції затримки використовуйте `time.Sleep(duration)`. Не забудьте імпортувати `time`.
- Для випадкових чисел: `rand.Intn(max)`. Не забудьте `rand.Seed(time.Now().UnixNano())` для ініціалізації генератора. Імпортуйте `math/rand` та `time`.

Коли ви виконаєте ці два завдання, надішліть мені код файлів `main.go` та будь-яких інших файлів, які ви створили.

Це буде складніший день, але дуже корисний для розуміння конкурентності в Go! Успіхів!